import 'mocha';
import assert from 'assert';
import { preprocessHarEntries, preprocess, trackingAPIComparisonSchema, HarEntry} from './har'
import fs from 'fs';
import path from 'path';

describe('preprocessHarEntries', () => {
  // Recordings 1 & 2 were generated on the same website using the same ajs, at different time
  // Recording 3 was generated on the same website as the first two, using a different AJS configuration that
  // produces a different tracking api payload
  
  it('should return true for identical recordings', () => {
    const a = preprocessHarEntries(fs.readFileSync(path.join(__dirname, 'test_data', 'recording1.har'), 'utf8'));
    const b = preprocessHarEntries(fs.readFileSync(path.join(__dirname, 'test_data', 'recording1.har'), 'utf8'));
    assert.deepEqual(a, b)
  });

  it('should return true for recordings generated by the same AJS on the same website', () => {
    const a = preprocessHarEntries(fs.readFileSync(path.join(__dirname, 'test_data', 'recording1.har'), 'utf8'));
    const b = preprocessHarEntries(fs.readFileSync(path.join(__dirname, 'test_data', 'recording2.har'), 'utf8'));
    assert.deepEqual(a, b)
  });

  it('should return false for recordings generated by different AJS configurations on the same website', () => {
    const a = preprocessHarEntries(fs.readFileSync(path.join(__dirname, 'test_data', 'recording1.har'), 'utf8'));
    const b = preprocessHarEntries(fs.readFileSync(path.join(__dirname, 'test_data', 'recording3.har'), 'utf8'));
    assert.notDeepEqual(a, b)
  });
});

describe('preprocess', () => {
  it('should ignore user-agent headers', () => {
    const a = {request: {headers: [{name: 'user-agent', value: 'foo'}]}} as HarEntry
    const b = {request: {headers: [{name: 'user-agent', value: 'bar'}]}} as HarEntry
    assert.deepEqual(
      preprocess(a, trackingAPIComparisonSchema),
      preprocess(b, trackingAPIComparisonSchema)
    )
  })

  it('should ignore user-agent header #2', () => {
    const a = {request: {headers: [{name: 'user-agent', value: 'foo'}]}} as HarEntry
    const b = {request: {headers: [{name: 'user-agent', value: 'foo'}]}} as HarEntry
    assert.deepEqual(
      preprocess(a, trackingAPIComparisonSchema),
      preprocess(b, trackingAPIComparisonSchema)
    )
  })

  it('compares object using a schema that contains properties we want to ignore / only care about existene', () => {
    const a = { b: 'foo', c: { d: 1 } };
    const b = { a: 1, b: 2, c: { d: 1 } };
    const schema = { ignored: ['a'], exists: ['b'] };
    assert.deepEqual(
      preprocess(a, schema),
      preprocess(b, schema)
    )
  })

  describe('ignore', () => {
    it('should ignore top-level properties', () => {
      const a = { a: 1, b: 2, c: { d: 1 } };
      const b = { a: 1, b: 'foobar', c: { d: 1 } };
      const schema = { ignored: ['b'] };
      assert.deepEqual(
        preprocess(a, schema),
        preprocess(b, schema)
      )
    })

    it('should ignore non top-level properties', () => {
      const a = { a: 1, b: 2, c: { d: 1 } };
      const b = { a: 1, b: 2, c: { d: 123 } };
      const schema = { ignored: ['c.d'] };
      assert.deepEqual(
        preprocess(a, schema),
        preprocess(b, schema)
      )
    })

    it('should ignored c.d but not entire c', () => {
      const a = { b: 2, c: { d: 2 } };
      const b = { a: 1, b: 2, c: { d: 1 } };
      const schema = { ignored: ['a', 'c.d'] };
      assert.deepEqual(
        preprocess(a, schema),
        preprocess(b, schema)
      )
    })

    it('should ignore c.d but not entire c #2', () => {
      const a = { b: 2 }
      const b = { a: 1, b: 2, c: { d: 1 } }
      const schema = { ignored: ['a', 'c.d'] }
      assert.notDeepEqual(
        preprocess(a, schema),
        preprocess(b, schema)
      )
    })

    it('should ignore entire c and its own properties', () => {
      const a = { a: 1, b: 2, c: { g: 1 } }
      const b = { a: 1, b: 2, c: { d: 1, e: 2, f: {} } }
      const schema = { ignored: ['c'] }
      assert.deepEqual(
        preprocess(a, schema),
        preprocess(b, schema)
      )
    })
  }) // describe ignore

  describe('exists', () => {
    it('should only check for existence of properties and ignore their values', () => {
      const a = { a: 123, b: 2, c: { d: 1 } }
      const b = { a: 1, b: 2, c: { d: 1 } }
      const schema = { exists: ['a'] }
      assert.deepEqual(
        preprocess(a, schema),
        preprocess(b, schema)
      )
    })

    it('should only check for existence of properties and ignore their values #2', () => {
      const a = { a: null, b: 2, c: { d: 1 } }
      const b = { a: 1, b: 2, c: { d: 1 } }
      const schema = { exists: ['a'] }
      assert.deepEqual(
        preprocess(a, schema),
        preprocess(b, schema)
      )
    })

    it('should return false when only one object is missing the property', () => {
      const a = { b: 2, c: { d: 1 } }
      const b = { a: 1, b: 2, c: { d: 1 } }
      const schema = { exists: ['a'] }
      assert.notDeepEqual(
        preprocess(a, schema),
        preprocess(b, schema)
      )
    })

    it('should work for multiple properties and nested props', () => {
      const a ={ a: 1, b: 2, c: { d: 1 } }
      const b ={ a: 1, b: 234, c: { d: 123 } }
      const schema ={ exists: ['b', 'c.d'] }
      assert.deepEqual(
        preprocess(a, schema),
        preprocess(b, schema)
      )
    })

    it('should work deeply nested objects', () => {
      const a = { a: 1, b: 2, c: { d: 2 } }
      const b = { a: 1, b: 2, c: { d: { e: { f: {} } } } }
      const schema = { exists: ['c'] }
      assert.deepEqual(
        preprocess(a, schema),
        preprocess(b, schema)
      )
    })

  }) // describe exists
}) // describe preprocess
