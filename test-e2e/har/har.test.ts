import 'mocha';
import * as assert from 'assert';
import { parseHttpArchiveText, compareEntries, isEquivalent } from './har'
import * as fs from 'fs';
import * as path from 'path';

describe('experiment', () => {
  it('should only care about attributes a and b', () => {
    let model = {
      a: {
        b: null
      },
      c: null
    }

    let o1 = {
      a: {
        b: 2,
        c: 3
      },
      c: 3,
      d: 4
    };

    console.log(`typeof b: ${typeof(model.a.b)}`)

    function pick<T>(model: T, obj: any): T {
      return Object.keys(model).reduce((res, key) => {
        if (!(key in obj)) return res;
        if (model[key] === null) {
          res[key] = obj[key]; 
          return res;
        }
        res[key] = pick(model[key], obj[key]);
        return res;
      }, {} as T)
    }
    console.log(pick(model, o1))
  })
})

describe('compareEntries', () => {
  // First two recordings were generated on the same website using the same ajs, at different time
  
  const recording1 = parseHttpArchiveText(fs.readFileSync(path.join(__dirname, 'test_data', 'recording1.har'), 'utf8'));
  const recording2 = parseHttpArchiveText(fs.readFileSync(path.join(__dirname, 'test_data', 'recording2.har'), 'utf8'));
  // Third recording was generated on the same website as the first two, using a different AJS configuration that
  // produces a different tracking api payload
  const recording3 = parseHttpArchiveText(fs.readFileSync(path.join(__dirname, 'test_data', 'recording3.har'), 'utf8'));
  
  it('should return true for identical recordings', () => {
    assert(compareEntries(recording1, recording1))
  });

  it('should return true for recordings generated by the same AJS on the same website', () => {
    assert(compareEntries(recording1, recording2));
  });

  it('should return false for recordings generated by different AJS configurations on the same website', () => {
    assert(!compareEntries(recording1, recording3),);
  });
});

describe('isEquivalent', () => {
  it('compares object using a schema that contains properties we want to ignore / only care about existene', () => {
    assert(
      isEquivalent(
        { b: 'foo', c: { d: 1 } },
        { a: 1, b: 2, c: { d: 1 } },
        { ignored: ['a'], exists: ['b'] }
      )
    );
  })
  describe('simple deep equal', () => {
    it('should perform deepEqual when no schemas were specified', () => {
      assert(
        isEquivalent({ a: 1, b: 2, c: { d: 1 } }, { a: 1, b: 2, c: { d: 1 } }, {})
      );
    })
    it('should also compare deeply nested objects', () => {
      assert(
        isEquivalent(
          { a: 1, b: 2, c: { d: { e: { f: {} } } } },
          { a: 1, b: 2, c: { d: { e: { f: {} } } } },
          {}
        )
      );
    })
  })

  describe('ignore', () => {
    it('should ignore top-level properties', () => {
      assert(
        isEquivalent(
          { a: 1, b: 2, c: { d: 1 } },
          { a: 1, b: 'foobar', c: { d: 1 } },
          { ignored: ['b'] }
        )
      );
    })

    it('should ignore non top-level properties', () => {
      assert(
        isEquivalent(
          { a: 1, b: 2, c: { d: 1 } },
          { a: 1, b: 2, c: { d: 123 } },
          { ignored: ['c.d'] }
        )
      );
    })

    it('should ignored c.d but not entire c', () => {
      assert(
        isEquivalent(
          { b: 2, c: { d: 2 } },
          { a: 1, b: 2, c: { d: 1 } },
          { ignored: ['a', 'c.d'] }
        )
      );

      assert(
        !isEquivalent(
          { b: 2 },
          { a: 1, b: 2, c: { d: 1 } },
          { ignored: ['a', 'c.d'] }
        ),
        'ignored c.d but not entire c #2'
      );
    })

    it('should ignore entire c and its own properties', () => {
      assert(
        isEquivalent(
          { a: 1, b: 2, c: { g: 1 } },
          { a: 1, b: 2, c: { d: 1, e: 2, f: {} } },
          { ignored: ['c'] }
        )
      );
    })
  }) // describe ignore

  describe('exists', () => {
    it('should only check for existence of properties and ignore their values', () => {
      assert(
        isEquivalent(
          { a: 123, b: 2, c: { d: 1 } },
          { a: 1, b: 2, c: { d: 1 } },
          { exists: ['a'] }
        )
      );

      assert(
        isEquivalent(
          { a: null, b: 2, c: { d: 1 } },
          { a: 1, b: 2, c: { d: 1 } },
          { exists: ['a'] }
        ),
        'exists: null value'
      );
    })

    it('should return false when only one object is missing the property', () => {
      assert(
        !isEquivalent(
          { b: 2, c: { d: 1 } },
          { a: 1, b: 2, c: { d: 1 } },
          { exists: ['a'] }
        ),
        'exists:  missing prop'
      );
    })

    it('should work for multiple properties and nested props', () => {
      assert(
        isEquivalent(
          { a: 1, b: 2, c: { d: 1 } },
          { a: 1, b: 234, c: { d: 123 } },
          { exists: ['b', 'c.d'] }
        )
      );
    })

    it('should work deeply nested objects', () => {
      assert(
        isEquivalent(
          { a: 1, b: 2, c: { d: 2 } },
          { a: 1, b: 2, c: { d: { e: { f: {} } } } },
          { exists: ['c'] }
        )
      );
    })
  }) // describe exists
}) // describe isEquivalent
