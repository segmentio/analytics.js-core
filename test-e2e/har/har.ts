import * as _ from 'lodash';

// A .har file contains more properties than defined here; however, these are the properties
// we care about when comparing network requests generated by analytics.js
interface HarEntry {
  request: {
    cookies: Array<any>,
    headers: Array<{name: string, value: string}>
    httpVersion: string
    method: string
    postData: {
      mimeType: string
      params: Array<any>
      text: string // this contains the tracking api payload
    },
    queryString: Array<any>,
    url: string
  }
  // In the .har file, there's a `response` property. We don't care about it since we are only
  // interested in what requests analytics.js are making
}

/*
Returns an object of type T by picking properties from `obj` that are found in `model`,
omitting properties that are not found in `model`.
*/
function pick<T>(model: T, obj: any): T {
  return Object.keys(model).reduce((res, key) => {
    if (!(key in obj)) return res;
    if (model[key] === null) {
      res[key] = obj[key]; 
      return res;
    }
    res[key] = pick(model[key], obj[key]);
    return res;
  }, {} as T)
}

/*
Takes some JSON string and coerce it into a HarEntry[]
*/
export function parseHttpArchiveText(harText: string): HarEntry[] {
  // coerce the HAR json object into the model we defined
  const obj = JSON.parse(harText) as {log: {entries: [any]}}
  let entries = obj.log.entries
  return entries.map(entry => pick({
    request: {
      cookies: null,
      headers: null, // []{name: string, value: string}
      httpVersion: null,
      method: null,
      postData: {
        mimeType: null,
        params: null,
        text: null // this contains the tracking api payload
      },
      queryString: null,
      url: null
    }
  } as HarEntry, entry)).map(entry => {
    // tracking api payload is a JSON string
    entry.request.postData.text = JSON.parse(entry.request.postData.text)
    return entry
  })
}

// properties that are not explicitly called out are assumed to require deep equal
interface compareSchema {
  ignored?: string[]
  exists?: string[]
}

const trackingAPIComparisonSchema: compareSchema = {
  // these properties only need to exist; their values are not considered when comparing
  exists: [
    'request.postData.text.timestamp',
    'request.postData.text.context.userAgent',
    'request.postData.text.context.library.version',
    'request.postData.text.messageId',
    'request.postData.text.anonymousId',
    'request.postData.text.writeKey',
    'request.postData.text.sentAt'
  ]
}

/*
    isEquivalent compares if objects a and b are equivalent
*/
export function isEquivalent(a: any, b: any, schema: compareSchema): boolean {
  if (schema.ignored && schema.ignored.length > 0) {
    // Remove ignored properties from objects; it does not matter whether they originally existed or not
    for (let key of schema.ignored) {
      _.unset(a, key)
      _.unset(b, key)
    }
  }

  if (schema.exists && schema.exists.length > 0) {
    for (let key of schema.exists) {
      // Overwrite property value with dummy one since we only care if the property exists
      if (_.has(a, key)) _.set(a, key, '')
      if (_.has(b, key)) _.set(b, key, '')
    }
  }
  return _.isEqual(a, b)
}

/*
compareEntries returns true if the entries in a and b are equivalent as defined
by trackingAPIComparisonSchema.
 */
export function compareEntries(a: HarEntry[], b: HarEntry[]): boolean {
  if (a.length !== b.length) {
    return false
  }
  for (let i = 0; i < a.length; i++) {
    if (!isEquivalent(a[i], b[i], trackingAPIComparisonSchema)) return false
  }
  return true
}
